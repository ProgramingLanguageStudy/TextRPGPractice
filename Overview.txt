클래스의 객체 총 정리

1. 클래스(Class)
- 정의: 객체를 만들기 위한 설계도
- 구성: 멤버 변수(데이터, 상태), 멤버 함수(기능)

2. 객체(Object)
- 정의: 클래스를 바탕으로 생성된 실제 데이터 묶음(인스턴스)
- 클래스에 정의된 방식으로 작동한 개별 데이터 묶음

3. 생성자(Constructor)
- 정의: 객체 생성 시 자동 호출
- 생성자 초기화 리스트: 생성자가 실행되기 전 멤버 변수를 초기화하는 기능
Hero(string name) : name_(name), hp_(100) { // 생성자 코드 }
- 자식 클래스 객체가 생성될 때 부모 클래스 생성자가 먼저 호출된다.

4. 소멸자(Destructor)
- 정의: 객체 소멸 시(메모리에서 해제될 때) 자동 호출
~Hero() { // 소멸자 코드 }
- 자식 클래스 객체가 소멸할 때 자식 클래스 소멸자가 먼저 호출된다.

5. 캡슐화(Encapsulation)와 접근 제어자(접근 한정자, Access Modifier)
- public: 객체 외부에서 접근 허용
- private: 객체 외부에서 접근 불가(클래스 내부에서만 접근 가능)
- protected: 자신 및 자식 클래스에서만 접근 허용
-> 캡슐화: 각 객체의 내부 정도는 각 객체 안에 은닉한다(숨긴다).

6. 상속(Inheritance)
- 정의: 기존 클래스의 멤버를 그대로 물려받게 하는 것
class Enemy : public Battler { //클래스 본문 };

- 효과: 코드의 재사용

- 사용 예
Battler -> Hero, Enemy
Enemy -> Goblin, Orc, Slime

7. 다형성(Polymorphism)
- 정의: 하나의 타입(부모 클래스)으로 여러 종류(자식 클래스)의 객체를 처리
class Battler{
public:
	virtual void PrintInfo();
};

class Enemy{
public:
	void PrintInfo() override;
};

- virtual: 이 함수는 다형성 대상이 되는 함수임을(가상 함수) 명시(부모 클래스 선언)
- override: 이 함수는 부모 클래스의 가상 함수를 재정의하고 있음을 명시(자식 클래스에서 선언)

8. 추상화(Abstraction)와 인터페이스(Interface)
- 추상화: 공통된 개념만 추출하고 세부 구현은 숨기는 객체 지향의 핵심 원칙
- 추상 클래스: 하나 이상의 순수 가상 함수를 포함하는 클래스(직접 객체 생성 불가)
- 순수 가상 함수: 자식 클래스에서 반드시 override해 구현해야 하는 가상 함수
virtual void TakeDamage(int amount) = 0;
(C#에서는 abstract 키워드가 따로 있어서 추상 클래스, 추상 함수를 만들 수 있다.)
- 인터페이스: 순수 가상 함수만으로 구성된 클래스(특정 기능의 구현을 강제)
C++에서는 인터페이스도 클래스이며, 일반적으로 'I~~' 형식으로 명명
일반적으로, 다중 상속 대신 단일 상속과 인터페이스 사용을 지향한다.
(가상 소멸자 필수! virtual ~IDamageable() = default;)
(C#에는 인터페이스가 따로 존재한다.)

9. SOLID 원칙
- 단일 책임 원칙(SRP, Single Responsibility Principle)
-> 하나의 클래스는 하나의 책임(역할)만 가져야 한다.

- 개방-폐쇄 원칙(OCP, Open-Closed Principle)
-> 기능의 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.
(기존 코드 수정 없이 새로운 기능 추가할 수 있도록 지향)

- 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
-> 자식 클래스는 부모 클래스 대신 사용될 수 있어야 한다.

- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
-> 크고 복잡한 인터페이스 하나보다, 작고 구체적인 인터페이스 여러 개로 분리하는 것이 낫다.

- 의존 역전의 원칙(Dependency Inversion Principle)
-> 상위 모듈이 하위 모듈에 의존하지 않고,
추상화(인터페이스, 추상 클래스)에 의존해야 한다.

10. 포인터
- 정의: 다른 변수의 메모리 주소를 저장하는 변수
- 객체는 하나만 생성한 후 포인터를 통해 간접적으로 제어
- 객체 포인터를 통해 다형성 활용

11. 스마트 포인터
- 정의: 메모리를 자동으로 관리해 주는 포인터
- 효과: new/delete 키워드 없이 변수의 생명 주기로 객체의 생명 주기를 자동 관리
- unique_ptr: 한 객체를 하나의 포인터만 소유
- shared_ptr: 참조 카운트를 통해 여러 포인터가 객체를 공유
- weak_ptr: shared_ptr의 순환 참조 방지용

12. cosnt(상수화, 읽기 전용)
- 변수 앞: 한번 값이 정해지면 수정 불가(읽기 전용 변수)
- 함수 뒤: 멤버 변수 수정이 불가능한 읽기 전용 함수
- 포인터 변수 앞: 읽기 전용 포인터(읽기 전용 함수만 사용 가능)

13. static(정적, 클래스 자체 소속)
- 지역 변수 앞: 함수 실행 후에도 값을 유지하는 변수
- 멤버 변수 앞: 모든 객체가 공유하는 클래스 자체에 소속된 변수

14. 구조체(Struct)
- C++에서는 클래스와 거의 동일하지만 기본 접근 제어자가 public
- 데이터를 저장하는 용도로만 사용 권장
- C#에서는 클래스와 달리 값 타입

15. 함수 오버로딩(Overloading) (*오버라이드와 헷갈리지 말 것)
- 정의: 같은 이름의 함수를 매개변수의 타입 또는 개수가 다르게
여러 개 정의할 수 있는 기능
void Print(int value);
void Print(string Text);
void Print(string text, int count);

16. 헤더파일(.h)
- 클래스의 정의, 인터페이스 선언 등을 저장하는 파일
- 각 클래스의 이름, 함수 형식(구현 X), 변수명을 선언하는 용도
- #Pragma once를 맨 위에