SOLID 원칙

실전에서 응용하기 위해 달달 외울 필요는 없다.
하지만 면접 때 물어보기 너무 좋다.

객체 지향을 잘하게 되면 SOLID 원칙은 자동으로 파생되는 개념이다.
객체 지향 입문 시에 가이드와 같은 역할

1. S
단일 책임 원칙(Single Responsibility Principle, SRP)
- 하나의 클래스는 하나의 책임만 가져야 한다.

클래스를 만들 때 특정한 한 역할만 수행하도록 설계해야 한다.
역할을 먼저 생각하고 클래스를 만드는 것이 좋다.

-> 가장 중요한 원칙. 이것만 잘해도 반은 먹고 들어간다.
-> 클래스의 역할 범위를 어느 정도로 할지 잘 정하면 된다.
-> 게임을 어느 정도까지 세세하게 역할 분담을 시킬지가 관건.

ex. 2D 플래포머 게임.
주인공 캐릭터가 이동, 점프, 공격 같은 기능만 갖고 있어야지
파일 저장, 점수 같은 기능을 갖고 있으면 안 된다.

Hero, Enemy, Goblin, Orc, Slime -> 각각 전투 캐릭터 역할 담당
TextRPG -> 게임 전체 흐름 담당

2. O
개방-폐쇄 원칙(Open-Colsed Principle, OCP)
- 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.

기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있어야 한다.
(기존 코드를 아예 수정하지 말아야 한다는 뜻은 아니다.)
기존과 전혀 관련 없는 새로운 기능 추가 시에
기존 기능들이 수정되는 일이 없어야 한다.
또한, 기존 코드 수정이 최대한 덜 되도록 처음부터 작업해야 한다는 뜻.
상속과 인터페이스로 구현할 수 있다.

-> 상속 구조 잘 짜면 된다.

ex. Enemy를 상속받는 Goblin, Orc, Slime
다 등장 시 메세지가 다르지만, 기존의 Enemy를 수정하지 않고 기능 추가
Enemy를 상속받는 또 다른 적 종류를 얼마든지 추가할 수 있지만,
기존의 TextRPG, Enemy, Hero 등 기존 코드들을 수정하지 않아도 된다.

3. L
리스코프 치환 원칙(Liskov Substitution Principle, LSP) (리스코프는 사람 이름)
- 자식 클래스는 부모 클래스를 대체할 수 있어야 한다.

클래스 상속 구조를 설계할 때
자식 클래스 객체가  부모 클래스 변수로도 얼마든지 사용될 수 있어야 한다.

ex. Enemy로 사용될 수 없는 Enemy의 자식 클래스는 만들지 말아야 한다.
이런 일이 발생하면 상속 설계를 잘못한 것.

Enemy* enemy = GenerteRandomEnemy();
FightEnemy(*enemy);		// Enemy의 자식들을 문제 없이 사용

4. I
인터페이스 분리 원칙(Interface Segregation Principle, ISP)
- 인터페이스는 각각 용도에 맞게끔 분리되어야 한다.

C++에서는 순수 가상 클래스.
C#에서는 인터페이스가 따로 있다.(Interface)

-> 인터페이스 배우면 된다.
사실, C++에서 인터페이스는 상속을 아주 잘 쓰는 기법이다.

5. D
의존(성) 역전의 원칙(Dependency Inversion Principle, DIP)
- 클래스는 어떤 상세 구현이 아닌 추상화(인터페이스 등)에 의존해야 한다.

상위 모듈이 하위 모듈에 의존해서는 안 된다.
(상위, 하위 모듈과 부모, 자식 상속은 전혀 다른 개념)
하위 모듈은 상위 모듈에 의존해도 되지만,
상위 모듈은 하위 모듈에 의존해서는 안 된다.

의존: 각 클래스 입장에서 다른 클래스가 어떻게 돌아가는지 알아야 하는 경우
A 클래스가 B가 어떻게 돌아가는지 알아야 한다면 A가 B에 의존한다고 한다.

ex. Hero 클래스가 Sword라는 구체적인 클래스에 의존하면 안 된다.
Weapon이라는 추상적인 부모 클래스를 만들어서 거기에 의존.

TextRPG가 Enemy에 의존하지만
구체적인 Goblin, Orc, Slime에 의존하지 않는다.




결론.
클래스를 아주 잘 다뤄 객체 단위로 효율적인 설계가 가능해지면,
SOLID 원칙은 자연스레 지켜지게 된다.
반대로, SOLID 원칙을 잘 지키는 데 숙달되었다는 건,
객체 지향을 잘하게 되었다는 뜻이기도 하다.

역할 분담(SRP)
OCP -> 각각의 클래스가 작고 역할이 분명하니 기존 코드 건들지 않고 확장 가능
LSP -> 자식 클래스도 부모의 역할에 더해 세부적인 추가 기능들만 가지면 되므로 치환도 잘됨.
ISP -> 인터페이스를 분리해서 만들라는 원칙. 책임 분리 잘하면 됨.
DIP -> 책임이 분명하면 추상화도 쉬움.

=> 당연히 면접 때는 각자 다 알아야 한다.


중요한 건 어느 정도까지 역할을 세분화할 것이냐.
프로그래머의 경험과 역량이 필요.

ex.
하나의 캐릭터를 하나의 클래스로 만들 수도 있겠지만,
(합체 로봇을 만들듯, 레고 조립하듯)
이동, 점프, 공격 등 각 기능을 별개의 부품(클래스)으로 작업할 수도 있다.